// src/app.rs

use crate::core::models::{AnalysisFinding, ScanReport, Severity};
use crate::logging;
use ratatui::widgets::ScrollbarState;
use std::fs;

/// Characters used for the animated loading spinner.
pub const SPINNER_CHARS: [char; 4] = ['|', '/', '-', '\\'];

/// Represents the status of a report export operation.
pub enum ExportStatus {
    /// No export operation is in progress.
    Idle,
    /// The export completed successfully. Contains the filename.
    Success(String),
    /// An error occurred during the export. Contains the error message.
    Error(String),
}

/// Defines the main states of the application's lifecycle.
#[derive(Default, PartialEq, Eq)]
pub enum AppState {
    /// The initial state, showing a disclaimer to the user.
    #[default]
    Disclaimer,
    /// The application is waiting for user input (e.g., a target domain).
    Idle,
    /// A scan is currently in progress.
    Scanning,
    /// The scan is complete, and results are displayed.
    Finished,
}

/// Holds a calculated summary of the scan results.
#[derive(Debug, Default)]
pub struct ScanSummary {
    /// A numerical score from 0 to 100 representing the security posture.
    pub score: u8,
    /// The total number of critical-severity issues found.
    pub critical_issues: usize,
    /// The total number of warning-severity issues found.
    pub warning_issues: usize,
    /// Indicates whether the DNS checks (SPF, DMARC, etc.) passed.
    pub dns_check_passed: bool,
    /// Indicates whether the SSL/TLS configuration checks passed.
    pub ssl_check_passed: bool,
    /// Indicates whether the security headers checks passed.
    pub headers_check_passed: bool,
}

/// The main application struct, holding all state information for the TUI.
pub struct App {
    /// A flag to determine if the application should exit.
    pub should_quit: bool,
    /// The current state of the application's lifecycle.
    pub state: AppState,
    /// The string input from the user (e.g., the target domain).
    pub input: String,
    /// The full report generated by the scan, available when the scan is finished.
    pub scan_report: Option<ScanReport>,
    /// A summary of the scan results.
    pub summary: ScanSummary,
    /// The current status of any report export operation.
    pub export_status: ExportStatus,
    /// The current frame index for the loading spinner animation.
    pub spinner_frame: usize,
    /// A consolidated list of all findings from all analysis categories.
    pub all_findings: Vec<AnalysisFinding>,
    /// The state for the scrollable list of analysis findings.
    pub analysis_list_state: ratatui::widgets::ListState,
    /// The score value currently being displayed, used for animation.
    pub displayed_score: u8,
    /// A flag to control the visibility of the log panel.
    pub show_logs: bool,
    /// The content of the log file to be displayed in the log panel.
    pub log_content: Vec<String>,
    /// The state for the horizontal scrollbar in the log panel.
    pub log_horizontal_scroll_state: ScrollbarState,
    /// The current horizontal scroll position for the log content.
    pub log_horizontal_scroll: usize,
}

impl App {
    /// Creates a new instance of the `App` with default values.
    pub fn new() -> Self {
        Self {  
            should_quit: false,
            state: AppState::default(),
            input: String::new(),
            scan_report: None,
            summary: ScanSummary::default(),
            export_status: ExportStatus::Idle,
            spinner_frame: 0,
            all_findings: Vec::new(),
            analysis_list_state: ratatui::widgets::ListState::default(),
            displayed_score: 0,
            show_logs: false,
            log_content: Vec::new(),
            log_horizontal_scroll_state: ScrollbarState::default(),
            log_horizontal_scroll: 0,
        }
    }
    
    /// Selects the next finding in the list, wrapping around to the start if at the end.
    pub fn select_next_finding(&mut self) {
        if self.all_findings.is_empty() { return; }
        let i = match self.analysis_list_state.selected() {
            Some(i) => (i + 1) % self.all_findings.len(),
            None => 0,
        };
        self.analysis_list_state.select(Some(i));
    }

    /// Selects the previous finding in the list, wrapping around to the end if at the start.
    pub fn select_previous_finding(&mut self) {
        if self.all_findings.is_empty() { return; }
        let i = match self.analysis_list_state.selected() {
            Some(i) => if i == 0 { self.all_findings.len() - 1 } else { i - 1 },
            None => 0,
        };
        self.analysis_list_state.select(Some(i));
    }
    
    /// Populates the `all_findings` vector by collecting all findings from the scan report.
    /// It chains the findings from DNS, SSL, and Headers results into a single list.
    pub fn update_findings(&mut self) {
        if let Some(report) = &self.scan_report {
            self.all_findings = report.dns_results.analysis.iter()
                .chain(report.ssl_results.analysis.iter())
                .chain(report.headers_results.analysis.iter())
                .cloned()
                .collect();

            // Select the first finding by default if the list is not empty.
            if !self.all_findings.is_empty() {
                self.analysis_list_state.select(Some(0));
            } else {
                self.analysis_list_state.select(None);
            }
        }
    }

    /// Called on every "tick" of the application loop.
    /// Used for animations like the spinner and the score counter.
    pub fn on_tick(&mut self) {
        // Animate the spinner while scanning.
        if matches!(self.state, AppState::Scanning) {
            self.spinner_frame = (self.spinner_frame + 1) % SPINNER_CHARS.len();
        }

        // Animate the score gauge when the scan is finished.
        if matches!(self.state, AppState::Finished) {
            if self.displayed_score < self.summary.score {
                // Increment the score gradually for a smooth animation.
                self.displayed_score = (self.displayed_score + 2).min(self.summary.score);
            }
        }
    }

    /// Sets the `should_quit` flag to true to signal the application to exit.
    pub fn quit(&mut self) { self.should_quit = true; }

    /// Resets the application state to its initial configuration, ready for a new scan.
    pub fn reset(&mut self) {
        self.state = AppState::Idle;
        self.input = String::new();
        self.scan_report = None;
        self.summary = ScanSummary::default();
        self.export_status = ExportStatus::Idle;
        self.spinner_frame = 0;
        self.all_findings = Vec::new();
        self.analysis_list_state.select(None);
        self.log_horizontal_scroll = 0;
        self.log_horizontal_scroll_state = ScrollbarState::default();
    }
    
    /// Calculates and populates the `ScanSummary` struct from the full scan report.
    /// It counts issues, calculates a score, and determines the pass/fail status of major check categories.
    pub fn update_summary(&mut self) {
        if let Some(report) = &self.scan_report {
            let all_analyses: Vec<_> = report.dns_results.analysis.iter()
                .chain(report.ssl_results.analysis.iter())
                .chain(report.headers_results.analysis.iter())
                .collect();
            
            // Count issues by severity.
            let criticals = all_analyses.iter().filter(|a| matches!(a.severity, Severity::Critical)).count();
            let warnings = all_analyses.iter().filter(|a| matches!(a.severity, Severity::Warning)).count();
            
            // Calculate score based on findings (15 points off for critical, 5 for warning).
            let score = 100_i16.saturating_sub((criticals * 15) as i16).saturating_sub((warnings * 5) as i16);
            
            // Determine if major scan categories passed successfully.
            let dns_check_passed = report.dns_results.spf.is_ok() && report.dns_results.dmarc.is_ok() && report.dns_results.dkim.is_ok() && report.dns_results.caa.is_ok();
            let ssl_check_passed = report.ssl_results.scan.is_ok();
            let headers_check_passed = report.headers_results.error.is_none() && report.headers_results.hsts.is_ok() && report.headers_results.csp.is_ok() && report.headers_results.x_frame_options.is_ok() && report.headers_results.x_content_type_options.is_ok();

            self.summary = ScanSummary {
                score: if score < 0 { 0 } else { score as u8 },
                critical_issues: criticals,
                warning_issues: warnings,
                dns_check_passed,
                ssl_check_passed,
                headers_check_passed,
            };
            
            // Reset the displayed score to 0 to trigger the animation.
            self.displayed_score = 0;
        }
    }

    /// Reads the application's log file and updates the `log_content` field.
    /// It reads the last 200 lines in reverse order for display.
    pub fn refresh_logs(&mut self) {
        let log_path = logging::get_data_dir().join(logging::LOG_FILE.clone());
        match fs::read_to_string(log_path) {
            Ok(content) => {
                self.log_content = content.lines().rev().take(200).map(String::from).collect();
            }
            Err(_) => {
                self.log_content = vec!["Could not read log file.".to_string()];
            }
        }
    }
}